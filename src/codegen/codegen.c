#include "codegen.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ═══════════════════════════════════════════════════════════════════════════
 * ASCII Art and Aesthetic Elements
 * ═══════════════════════════════════════════════════════════════════════════ */

static const char* ascii_art_header = 
"/* ═══════════════════════════════════════════════════════════════════════════\n"
" *     ╔═══════════════════════════════════════════════════════════════╗\n"
" *     ║                    OBFUSCATED C CODE                         ║\n"
" *     ║                  Generated by Obfuscator                     ║\n"
" *     ╚═══════════════════════════════════════════════════════════════╝\n"
" * ═══════════════════════════════════════════════════════════════════════════ */\n\n";

static const char* separator_line = 
"/* ═══════════════════════════════════════════════════════════════════════════ */\n";

static const char* aesthetic_comments[] = {
    "/* ✧･ﾟ: *✧･ﾟ:* Obfuscated Beauty *:･ﾟ✧*:･ﾟ✧ */",
    "/* ◆◇◆◇◆ Encrypted Logic ◆◇◆◇◆ */",
    "/* ▓▒░ Hidden Implementation ░▒▓ */",
    "/* ★☆★ Aesthetic Chaos ★☆★ */",
    NULL
};

/* ═══════════════════════════════════════════════════════════════════════════
 * Code Generator State Management
 * ═══════════════════════════════════════════════════════════════════════════ */

CodeGenState* codegen_create(CodeGenConfig* config) {
    CodeGenState* gen = malloc(sizeof(CodeGenState));
    if (!gen) return NULL;
    
    gen->config = config;
    gen->buffer_size = 65536; // Start with 64KB
    gen->output_buffer = malloc(gen->buffer_size);
    gen->buffer_pos = 0;
    gen->indent_level = 0;
    gen->errors = NULL;
    
    if (!gen->output_buffer) {
        free(gen);
        return NULL;
    }
    
    gen->output_buffer[0] = '\0';
    return gen;
}

void codegen_destroy(CodeGenState* gen) {
    if (!gen) return;
    
    free(gen->output_buffer);
    // TODO: Free error list
    free(gen);
}

bool codegen_has_errors(const CodeGenState* gen) {
    return gen && gen->errors != NULL;
}

Error* codegen_get_errors(const CodeGenState* gen) {
    return gen ? gen->errors : NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * Output Buffer Management
 * ═══════════════════════════════════════════════════════════════════════════ */

static void ensure_buffer_capacity(CodeGenState* gen, size_t additional_size) {
    if (gen->buffer_pos + additional_size >= gen->buffer_size) {
        size_t new_size = gen->buffer_size * 2;
        while (new_size < gen->buffer_pos + additional_size) {
            new_size *= 2;
        }
        
        char* new_buffer = realloc(gen->output_buffer, new_size);
        if (new_buffer) {
            gen->output_buffer = new_buffer;
            gen->buffer_size = new_size;
        }
    }
}

void codegen_write(CodeGenState* gen, const char* str) {
    if (!gen || !str) return;
    
    size_t len = strlen(str);
    ensure_buffer_capacity(gen, len + 1);
    
    strcpy(gen->output_buffer + gen->buffer_pos, str);
    gen->buffer_pos += len;
}

void codegen_write_char(CodeGenState* gen, char c) {
    if (!gen) return;
    
    ensure_buffer_capacity(gen, 2);
    gen->output_buffer[gen->buffer_pos++] = c;
    gen->output_buffer[gen->buffer_pos] = '\0';
}

void codegen_write_line(CodeGenState* gen, const char* str) {
    codegen_write(gen, str);
    codegen_newline(gen);
}

void codegen_newline(CodeGenState* gen) {
    codegen_write_char(gen, '\n');
}

void codegen_indent(CodeGenState* gen) {
    if (!gen) return;
    
    for (int i = 0; i < gen->indent_level; i++) {
        if (gen->config && gen->config->indent_size > 0) {
            for (int j = 0; j < gen->config->indent_size; j++) {
                codegen_write_char(gen, ' ');
            }
        } else {
            codegen_write(gen, "    "); // Default 4 spaces
        }
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * Aesthetic Formatting Functions
 * ═══════════════════════════════════════════════════════════════════════════ */

void generate_ascii_art_header(CodeGenState* gen, const char* title) {
    if (!gen) return;
    
    if (gen->config && gen->config->add_comments) {
        codegen_write(gen, ascii_art_header);
    }
}

void generate_aesthetic_comment(CodeGenState* gen, const char* text) {
    if (!gen || !gen->config || !gen->config->add_comments) return;
    
    static int comment_index = 0;
    int aesthetic_count = 0;
    while (aesthetic_comments[aesthetic_count]) aesthetic_count++;
    
    if (text) {
        codegen_write(gen, "/* ");
        codegen_write(gen, text);
        codegen_write(gen, " */");
    } else {
        codegen_write(gen, aesthetic_comments[comment_index % aesthetic_count]);
        comment_index++;
    }
    codegen_newline(gen);
}

void add_visual_separators(CodeGenState* gen) {
    if (!gen || !gen->config || !gen->config->add_comments) return;
    
    codegen_write(gen, separator_line);
}

void apply_creative_formatting(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node || !gen->config) return;
    
    switch (gen->config->style) {
        case AESTHETIC_ARTISTIC:
            if (node->type == NODE_FUNCTION) {
                generate_aesthetic_comment(gen, NULL);
            }
            break;
            
        case AESTHETIC_CHAOTIC:
            // Add random spacing and comments
            if (rand() % 3 == 0) {
                codegen_newline(gen);
                generate_aesthetic_comment(gen, "/* chaos */");
            }
            break;
            
        default:
            break;
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * AST Node Code Generation
 * ═══════════════════════════════════════════════════════════════════════════ */

void generate_expression(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    switch (node->type) {
        case NODE_LITERAL:
            codegen_write(gen, node->data.literal.value);
            break;
            
        case NODE_IDENTIFIER:
            codegen_write(gen, node->data.identifier.name);
            break;
            
        case NODE_BINARY_OP: {
            bool needs_parens = (node->data.binary.left->type == NODE_BINARY_OP ||
                               node->data.binary.right->type == NODE_BINARY_OP);
            
            if (needs_parens) codegen_write_char(gen, '(');
            generate_expression(gen, node->data.binary.left);
            
            // Add spacing around operators for readability
            if (gen->config && gen->config->pretty_print) {
                codegen_write_char(gen, ' ');
            }
            
            codegen_write(gen, node->data.binary.operator);
            
            if (gen->config && gen->config->pretty_print) {
                codegen_write_char(gen, ' ');
            }
            
            generate_expression(gen, node->data.binary.right);
            if (needs_parens) codegen_write_char(gen, ')');
            break;
        }
        
        case NODE_UNARY_OP:
            if (node->data.unary.is_prefix) {
                codegen_write(gen, node->data.unary.operator);
                generate_expression(gen, node->data.unary.operand);
            } else {
                generate_expression(gen, node->data.unary.operand);
                codegen_write(gen, node->data.unary.operator);
            }
            break;
            
        case NODE_CALL:
            generate_expression(gen, node->data.call.function);
            codegen_write_char(gen, '(');
            
            ASTNode* arg = node->data.call.arguments;
            while (arg) {
                generate_expression(gen, arg);
                if (arg->next) {
                    codegen_write(gen, ", ");
                }
                arg = arg->next;
            }
            
            codegen_write_char(gen, ')');
            break;
            
        case NODE_ASSIGNMENT:
            generate_expression(gen, node->data.binary.left);
            codegen_write(gen, " = ");
            generate_expression(gen, node->data.binary.right);
            break;
            
        default:
            // Handle other expression types
            break;
    }
}

void generate_statement(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    switch (node->type) {
        case NODE_IF:
            codegen_indent(gen);
            codegen_write(gen, "if (");
            generate_expression(gen, node->data.if_stmt.condition);
            codegen_write(gen, ")");
            
            if (gen->config && gen->config->pretty_print) {
                codegen_write_char(gen, ' ');
            }
            
            generate_statement(gen, node->data.if_stmt.then_stmt);
            
            if (node->data.if_stmt.else_stmt) {
                codegen_write(gen, " else ");
                generate_statement(gen, node->data.if_stmt.else_stmt);
            }
            break;
            
        case NODE_WHILE:
            codegen_indent(gen);
            codegen_write(gen, "while (");
            generate_expression(gen, node->data.while_stmt.condition);
            codegen_write(gen, ")");
            
            if (gen->config && gen->config->pretty_print) {
                codegen_write_char(gen, ' ');
            }
            
            generate_statement(gen, node->data.while_stmt.body);
            break;
            
        case NODE_FOR:
            codegen_indent(gen);
            codegen_write(gen, "for (");
            
            if (node->data.for_stmt.init) {
                generate_statement(gen, node->data.for_stmt.init);
            }
            codegen_write(gen, "; ");
            
            if (node->data.for_stmt.condition) {
                generate_expression(gen, node->data.for_stmt.condition);
            }
            codegen_write(gen, "; ");
            
            if (node->data.for_stmt.update) {
                generate_expression(gen, node->data.for_stmt.update);
            }
            
            codegen_write(gen, ")");
            
            if (gen->config && gen->config->pretty_print) {
                codegen_write_char(gen, ' ');
            }
            
            generate_statement(gen, node->data.for_stmt.body);
            break;
            
        case NODE_BLOCK:
            codegen_write_char(gen, '{');
            codegen_newline(gen);
            gen->indent_level++;
            
            generate_block(gen, node);
            
            gen->indent_level--;
            codegen_indent(gen);
            codegen_write_char(gen, '}');
            codegen_newline(gen);
            break;
            
        case NODE_RETURN:
            codegen_indent(gen);
            codegen_write(gen, "return");
            
            // TODO: Handle return expression
            codegen_write_char(gen, ';');
            codegen_newline(gen);
            break;
            
        default:
            // Handle expression statements
            codegen_indent(gen);
            generate_expression(gen, node);
            codegen_write_char(gen, ';');
            codegen_newline(gen);
            break;
    }
}

void generate_variable(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    codegen_indent(gen);
    
    // Add storage class specifiers
    if (node->data.variable.is_static) {
        codegen_write(gen, "static ");
    }
    
    if (node->data.variable.is_const) {
        codegen_write(gen, "const ");
    }
    
    // Type
    if (node->data.variable.type) {
        codegen_write(gen, node->data.variable.type);
        codegen_write_char(gen, ' ');
    }
    
    // Name
    codegen_write(gen, node->data.variable.name);
    
    // Initializer
    if (node->data.variable.initializer) {
        codegen_write(gen, " = ");
        generate_expression(gen, node->data.variable.initializer);
    }
    
    codegen_write_char(gen, ';');
    codegen_newline(gen);
}

void generate_function(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    // Add aesthetic formatting for functions
    apply_creative_formatting(gen, node);
    
    codegen_indent(gen);
    
    // Storage class
    if (node->data.function.is_static) {
        codegen_write(gen, "static ");
    }
    
    // Return type
    if (node->data.function.return_type) {
        codegen_write(gen, node->data.function.return_type);
        codegen_write_char(gen, ' ');
    }
    
    // Function name
    codegen_write(gen, node->data.function.name);
    codegen_write_char(gen, '(');
    
    // Parameters
    ASTNode* param = node->data.function.parameters;
    while (param) {
        // TODO: Generate parameter
        if (param->next) {
            codegen_write(gen, ", ");
        }
        param = param->next;
    }
    
    codegen_write_char(gen, ')');
    
    if (gen->config && gen->config->pretty_print) {
        codegen_write_char(gen, ' ');
    }
    
    // Function body
    if (node->data.function.body) {
        generate_statement(gen, node->data.function.body);
    } else {
        codegen_write_char(gen, ';');
        codegen_newline(gen);
    }
    
    codegen_newline(gen);
}

void generate_block(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    ASTNode* stmt = node->data.block.statements;
    while (stmt) {
        generate_statement(gen, stmt);
        stmt = stmt->next;
    }
}

void generate_program(CodeGenState* gen, ASTNode* node) {
    if (!gen || !node) return;
    
    // Generate header
    generate_ascii_art_header(gen, "Obfuscated C Code");
    
    // Process all top-level declarations
    ASTNode* decl = node->data.program.declarations;
    while (decl) {
        switch (decl->type) {
            case NODE_FUNCTION:
                generate_function(gen, decl);
                break;
                
            case NODE_VARIABLE:
                generate_variable(gen, decl);
                break;
                
            default:
                generate_statement(gen, decl);
                break;
        }
        
        decl = decl->next;
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * Main Code Generation Interface
 * ═══════════════════════════════════════════════════════════════════════════ */

char* generate_code(CodeGenState* gen, ASTNode* ast) {
    if (!gen || !ast) return NULL;
    
    // Reset buffer
    gen->buffer_pos = 0;
    gen->indent_level = 0;
    gen->output_buffer[0] = '\0';
    
    // Generate code based on AST root type
    switch (ast->type) {
        case NODE_PROGRAM:
            generate_program(gen, ast);
            break;
            
        case NODE_FUNCTION:
            generate_function(gen, ast);
            break;
            
        default:
            generate_statement(gen, ast);
            break;
    }
    
    return strdup(gen->output_buffer);
}

/* ═══════════════════════════════════════════════════════════════════════════
 * Configuration Management
 * ═══════════════════════════════════════════════════════════════════════════ */

CodeGenConfig* codegen_config_create_default(void) {
    CodeGenConfig* config = malloc(sizeof(CodeGenConfig));
    if (!config) return NULL;
    
    config->pretty_print = true;
    config->indent_size = 4;
    config->add_comments = true;
    config->add_ascii_art = true;
    config->style = AESTHETIC_ARTISTIC;
    
    return config;
}

void codegen_config_destroy(CodeGenConfig* config) {
    if (!config) return;
    free(config);
}

void codegen_config_set_style(CodeGenConfig* config, AestheticStyle style) {
    if (!config) return;
    config->style = style;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * Debug Information (Placeholder)
 * ═══════════════════════════════════════════════════════════════════════════ */

void generate_debug_mapping(CodeGenState* gen, const char* original, const char* obfuscated) {
    // TODO: Implement debug mapping generation
    (void)gen; (void)original; (void)obfuscated;
}

void preserve_line_numbers(CodeGenState* gen, SourceLocation location) {
    // TODO: Implement line number preservation
    (void)gen; (void)location;
}